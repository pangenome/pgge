#!/usr/bin/env bash

# exit when any command fails
set -eo pipefail

input_gfa=false
input_fasta=false
input_gaf=false
output_gaf=false
splitfa=false
seq_length=false
step=false
beehave_R=false
threads=1

if [ $# -eq 0 ];
then
    show_help=true
fi

## TODO add options for GraphAligner
## TODO add output-folder option

# read the options
cmd=$0" "$@
TEMP=`getopt -o g:f:i:r:o:l:s:t:h --long input-gfa:,input-fasta:,input-gaf:,beehave-r:,output-gaf:,seq_length:,step:,threads:,help -n 'pggb' -- "$@"`
eval set -- "$TEMP"

# extract options and their arguments into variables.
while true ; do
    case "$1" in
        -g|--input-gfa) input_gfa=$2 ; shift 2 ;;
        -f|--input-fasta) input_fasta=$2 ; shift 2 ;;
        -i|--input-gaf) input_gaf=$2 ; shift 2 ;;
        -r|--beehave-r) beehave_R=$2 ; shift 2 ;;
        -o|--output-gaf) output_gaf=$2 ; shift 2 ;;
        -l|--seq-length) seq_length=$2 ; shift 2 ;;
        -s|--step) step=$2 ; shift 2 ;;
        -t|--threads) threads=$2 ; shift 2 ;;
        -h|--help) show_help=true ; shift ;;
        --) shift ; break ;;
        *) echo $2 "Internal error!" ; exit 1 ;;
    esac
done

if [[
    $input_gaf == false
    ]];
then
    if [[
           $input_fasta == false
        || $input_gfa == false
        || $output_gaf == false
        || $beehave_R == false
    ]];
    then 
    show_help=true
    >&2 echo "Mandatory arguments -g, -f, -o, -r. If running in GAF-MODE, only -i, -r are required."
    fi
else
    if [[
           $input_fasta != false
        || $input_gfa != false
        || $output_gaf != false
    ]];
    then 
    show_help=true
    >&2 echo "Running in GAF-MODE, only -i, -r are a mandatory argument. Please remove any non GAF-MODE arguments -g, -f, -o, -r."
    fi
fi

# do we need to use splitfa?
if [[
    $seq_length != false 
    ]];
then
    if [[
        $step == false
    ]];
    then
        show_help=true
        >&2 echo "Mandatory arguments to run splitfa are -l and -s."
    fi
fi   

if [[
    $step != false 
    ]];
then
    if [[
        $seq_length == false
    ]];
    then
        show_help=true
        >&2 echo "Mandatory arguments to run splitfa are -l and -s."
    fi
fi    

if [[
    $step != false ]] && [[ $seq_length != false
    ]];
then   
    splitfa=true
fi

if [ $show_help ];
then
    padding=`printf %${#0}s` # prints as many spaces as the length of $0
    echo "usage:    $0 -g <input-gfa> -f <input-fasta> -o <output-gaf> [options]"
    echo
    echo "GAF-MODE: $0 -i <input-gaf> [options]"
    echo
    echo "options:"
    echo "   [evaluation]"
    echo "    -g, --input-gfa FILE        input GFA file"
    echo "    -f, --input-fasta FILE      input FASTA file"
    echo "    -o, --output-gaf FILE       output GAF file"
    echo "    -r, --beehave-r PATH        path to beehave.R"
    echo "   [splitfa]"
    echo "    -l, --seq-length N          length of the splits"
    echo "    -s, --step N                step size between splits"
    echo "   [evaluation-gaf-mode]"
    echo "    -i, --input-gaf FILE        input GFA file"
    echo "   [general]"
    echo "    -t, --threads N             number of compute threads to use in parallel steps"
    echo "    -h, --help                  this text"
    echo
    echo "Uses GraphAligner and peanut to evaluate a pangenome graph."
    exit
fi

f=$output_gaf

date=`date "+%m-%d-%Y_%H:%M:%S"`
log_file=$f.$date.log
param_file=$f.$date.params.yml

fmt="%C\n%Us user %Ss system %P cpu %es total %MKb max memory"
timer=/usr/bin/time

# write parameters to log_file:
echo -e "Starting pgge on `date`\n" > $log_file
echo -e "Command: $cmd\n" >> $log_file
echo -e "PARAMETERS\n" >> $log_file

# TODO UPDATE THIS
cat <<EOT | tee -a $log_file $param_file >/dev/null
evaluation:
  input-gfa:          $input_gfa
  input-fasta:        $input_fasta
  output-gaf:         $output_gaf
general:
  threads:            $threads
EOT
echo -e "\nRunning pgge\n" >> $log_file

# do we already have a FASTA index for the input_fasta?
if [[
    ! -f $input_fasta.fai
    ]];
then
    $timer -f "$fmt" samtools \
    faidx $input_fasta \
    2> >(tee -a $log_file)
fi
input_fai=$input_fasta.fai

echo $input_fai

# split into samples by "." and then by "#" always taking the first hit
cat $input_fai| cut -f 1 | cut -f 1 -d. | cut -f 1 -d '#' | sort | uniq | while read n; \
do $timer -f "$fmt" samtools faidx $input_fasta $(grep $n $input_fai | cut -f 1) > $input_fai.$n.fa; \
done 2> >(tee -a $log_file)

if [[
    $splitfa != false
    ]];
then
    cat $input_fai| cut -f 1 | cut -f 1 -d. | cut -f 1 -d '#' | sort | uniq | while read n; \
    do $timer -f "$fmt" splitfa $input_fai.$n.fa -l $seq_length -s $step > $input_fai.$n.splitfa.l100000s50000.fa; \
    done 2> >(tee -a $log_file)
fi

#cat $input_fai| cut -f 1 | cut -f 1 -d. | cut -f 1 -d '#' | sort | uniq | while read n; \
#do
#    $timer -f "$fmt" GraphAligner \
#        -g $input_gfa \
#        -f $input_fai.$n.splitfa.l100000s50000.fa \
#        -a $input_fai.$n.splitfa.fa.l100000s50000.fa.$output_gaf \
#        -x vg \
#        -t $threads \
#        2> >(tee -a $log_file)
#    ($timer -f "$fmt" cut -f 2,3,4,16 $input_fai.$n.splitfa.fa.l100000s50000.fa.$output_gaf \
#        | sed s/id:f:// \
#        | awk '{ len=$3-$2; tlen+=len; sum+=$4*len; } END { print sum / tlen }' \
#        | tr "\n" "\t" \
#        1> $input_fai.$n.splitfa.fa.l100000s50000.fa.$output_gaf.pgge) 2> >(tee -a $log_file) 
#    ($timer -f "$fmt" peanut \
#        -g $input_fai.$n.splitfa.fa.l100000s50000.fa.$output_gaf \
#        1>> $input_fai.$n.splitfa.fa.l100000s50000.fa.$output_gaf.pgge) 2> >(tee -a $log_file);
#done

input_gfa="$(basename -- $input_gfa)"

(echo sample.name cons.jump aln.id qsc uniq multi nonaln; ls | grep splitfa | grep pgge$ | while read f; \
do 
    echo $(echo $f | cut -f 5 -d .) $(echo $f | cut -f 2 -d @ | cut -f 1 -d. ) $(cat $f); \
done) | tr ' ' '\t' > $input_gfa.pgge.tsv

$timer -f "$fmt" Rscript \
    $beehave_R $input_gfa.pgge.tsv \
    $input_gfa.pgge.tsv.png \
    2> >(tee -a $log_file)
# TODO
exit 0

if [[
    $input_gaf == false
    ]];
then
    $timer -f "$fmt" GraphAligner \
        -g $input_gfa \
        -f $input_fasta \
        -a $output_gaf \
        -x vg \
        -t $threads \
        2> >(tee -a $log_file)

    ($timer -f "$fmt" cut -f 2,3,4,16 $output_gaf \
        | sed s/id:f:// \
        | awk '{ len=$3-$2; tlen+=len; sum+=$4*len; } END { print sum / tlen }' \
        | tr "\n" "\t" \
        1> $output_gaf.pgge) 2> >(tee -a $log_file) 
fi

if [[
    $input_gaf != false
    ]];
then
    output_gaf=$input_gaf
    echo "" > $output_gaf.pgge
fi

($timer -f "$fmt" peanut \
    -g $output_gaf \
    1>> $output_gaf.pgge) 2> >(tee -a $log_file)
